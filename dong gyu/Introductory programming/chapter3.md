# 3장 : 화면 입출력과 리스트 - 프로그래밍 환경

### GUI(Graphical User Interface) : 사용자 인터페이스
### CLI(Command Line Interface) : 마우스의 클릭이 아닌 키보드만으로 명령을 입력하는 환경

# 3장 : 화면 입출력과 리스트 - 화면 입출력

## 표준 입력 함수 : input() 함수
- input() 함수 : 표준 입력 함수로, 사용자가 문자열을 콘솔 창에 입력할 수 있게 해 준다.
```py
print("Enter your name:")
somebody = input()   # 콘솔 창에서 입력한 값을 somebody에 저장
print("Hi",somebody,"How are you today?")
```

## 표준 출력 함수 : print() 함수
- print() 함수 : 표준 출력 함수로, 결과를 화면에 출력하는 함수이다.
  - print() 함수 안 콤마(,)에 대해 
```py
print("Hello World!", "Hello Again!!!")
Hello World! Hello Again
```
콤마(,)를 사용하면 'Hello World!'와 'Hello Again!!!' 사이에 한 칸을 띠고 화면에 출력됨
- 콤마(,)와 +기호의 차이점 : +기호는 자료형이 모두 문자형이어야 하지만, 콤마는 변수의 자료형과 관계없이 출력할 수 있다.

## input() 함수를 이용하여 print() 함수 없이 지시문 출력하기

이전 코드에서는 input() 함수를 사용하기 전, 지시문을 출력하기 위해 print함수를 이용했다.
```py
print("Enter your name:")
```
하지만 밑 코드 처럼 input() 함수에 바로 지시문을 집어 넣을 수도 있다.
```py
temperature = float(input("온도를 입력하세요:"))    #입력 시 바로 형 전환
print(temperature)
```
- 주의점 : input() 함수가 값을 입력받으면 그 값의 자료형은 문자형이된다.
  - 위 코드는 문자열로 받은 데이터를 float() 함수를 이용해서 바로 실수형으로 전환했다.

# 3장 : 화면 입출력과 리스트 - 리스트의 이해
## 리스트의 개념
- 리스트(list) : 하나의 변수에 여러 값을 할당하는 자료형이다.
  - 리스트는 하나의 자료형으로만 저장하지 않고, 정수형이나 실수형 같은 다양한 자료형을 포함할 수 있다. 
  - 파이썬에서는 리스트처럼 여러 데이터를 하나의 변수에 할당하는 기법을 시퀸스 자료형이라 한다.
- 시퀸스 자료형 : 여러 자료를 순서대로 넣는다.
```py
colors = ['red', 'blue', 'green']
```
colors라는 변수를 하나 생성하고, 리스트 자료형을 할당한 경우이다.
- 리스트 할당을 위해 대괄호를 사용하고, 리스트 안에 있는 값을 각각 ['red', 'blue', 'green'] 형태로 할당했다.
- colors라는 변수는 3개의 값을 가지며, 각각의 값은 문자형의 red, blue, green이 된다.

## 인덱싱과 슬라이싱
## 인덱싱(indexing)

- 인덱싱 : 리스트에 있는 값에 접근하기 위해, 이 값의 상대적인 주소(offset)를 사용하는 것이다.
- 주소 : 간단히 말해 첫 번째 값을 0으로 했을 때 첫 번째 값과 얼마나 떨어져 있는지를 표현한 값으로, 일반적으로 인덱스 주소 또는 인덱스값이라고 한다.

![image]([](..\..\..\..\..\..\..\Lumiere001\SW-Mentoring\commit\bc723ef7d203930b4558ebf888962d904b1bb0e1))
  - len() 함수 : 리스트 안에 있는 값의 개수를 반환한다.

## 슬라이싱(slicing)
- 슬라이싱 : 리스트의 인덱스를 사용하여 전체 리스트에서 일부를 잘라내어 반환한다.

### 슬라이싱의 기본 문법
```
변수명[시작 인덱스:마지막 인덱스]
```

```python
cities=['서울','부산','인천','대구','대전','광주','울산','수원']
cities[0:6]
  ['서울','부산','인천','대구','대전','광주']
```
- 주의점 : 파이썬의 리스트에서 마지막 인덱스 값은 출력되지 않으므로 '광주'까지만 출력이 된다.
  - 정확히는 '마지막 인덱스 -1'까지만 출력된다. 아래의 코드를 보면 그 이유를 좀 더 쉽게 이해할 수 있다.

```python
cities[0:5]
  ['서울','부산','인천','대구','대전']
cities[5:]                    #리스트 5번부터 출력
  ['광주','울산','수원']
```
- 만약 한 번 이상 리스트 변수를 사용하면 마지막 인덱스가 다음 리스트의 시작 인덱스가 되어 코드를 작성할 때 조금 더 쉽게 이해할 수 있다.

## 리버스 인덱스(reverse index)
 - 리버스 인덱스 : 인덱스를 마지막 값부터 시작한다.
   - 기존 인덱스와 달리 마지막 값부터 -1을 할당하여 첫 번째 값까지 역순으로 올라오는 방식이다. 

아래의 코드를 보자
```python
cities=['서울','부산','인천','대구','대전','광주','울산','수원']
print(cities[-8:])
  ['서울','부산','인천','대구','대전','광주','울산','수원']
```
- 일반적으로 시작 인덱스가 비어 있으면 처음부터, 마지막 인덱스가 비어 있으면 마자막까지라는 의미로 사용된다.
  - 즉, cities[8:]은 인덱스가 -8인 '서울'부터 '수원'까지 출력하라는 뜻이다.

## 인덱스 범위를 넘어가는 슬라이싱(slicing with over index)
아래의 코드를 보자
```python
cities=['서울','부산','인천','대구','대전','광주','울산','수원']
print[cities[:]]        # cities 변수의 처음부터 끝까지
  ['서울','부산','인천','대구','대전','광주','울산','수원']
print(cities[-50:50])   # 범위를 넘어갈 경우 자동으로 최대 범위를 지정
  ['서울','부산','인천','대구','대전','광주','울산','수원']
```
- 인덱스를 따로 넣지 않고 print(cities[:])과 같이 콜론(:)을 넣으면 cities변수의 모든 값을 다 반환한다.
- 슬라이싱에서는 인덱스를 넘어서거나 입력하지 않더라도 자동으로 시작 인덱스와 마지막 인덱스로 지정된다.

## 증가값(step)
- 슬라이싱에서는 시작 인덱스와 마지막 인덱스 외에 마지막 자리에 증가값을 넣을 수 있다.
```
변수명[시작 인덱스:마지막 인덱스:증가값]
```
- 증가값은 한 번에 건너뛰는 값의 개수이다.

예시 코드
```python
cities=['서울','부산','인천','대구','대전','광주','울산','수원']
cities[::2]
  ['서울','인천','대전','울산']                             #2칸 단위로
cities[::-1]
  ['수원','울산','광주','대전','대구','인천','부산','서울']  #역으로 슬라이싱
```

## 리스트의 연산
## 덧셈 연산
- 덧셈 연산을 하더라도 따로 어딘가 변수에 할당해 주지 않으면 기존 변수는 변화가 없다.
```py
color1=['red','blue','green']
color2=['orange','black','white']
print(color1+color2)        #두 리스트 합치기
  ['red','blue','green','orange','black','white']
len(color1)                 #리스트 길이
  3
total_color=color1+color2
total_color
  ['red','blue','green','orange','black','white']
```

## 곱셈 연산
- 곱셈 연산 : 리스트의 곱셈 연산은 기준 리스트에 n을 곱했을 때, 같은 리스트를 n배 만큼 늘려 준다.
```py
color1*2          #color1 리스트 2회 반복
  ['red','blue','green','red','blue','green']
```

## in연산
- in연산 : 포함 여부를 확인하는 연산으로, 하나의 값이 해당 리스트에 들어 있는지 확인할 수 있다.
```py
'blue' in color2    #color2 변수에서 문자열 'blue'의 존재 여부 반환
  False
```

## 리스트 추가 및 삭제
## append() 함수
- append() 함수를 사용하면 리스트 맨 끝 인덱스에 새로운 값을 추가할 수 있다.
```py
color=['red','blue','green']
color.append('white')       #리스트에 'white' 추가
color
  ['red','blue','green','white']
```

## extend() 함수
- 새로운 리스트를 기존 리스트에 추가
```py
color=['red','blue','green']

color.extend(['black','purple'])       #리스트에 새로운 리스트 추가
color
  ['red','blue','green','black','purple']
```
## insert() 함수
- 기존 리스트의 i번째 인덱스에 새로운 값을 추가, i번째 인덱스를 기준으로 뒤쪽의 인덱스가 하나씩 밀림.
```py
color=['red','blue','green']

color.insert(0,'orange')
color
  ['orange','red','blue','green']
```
## remove() 함수
- 리스트 내의 특정 값을 삭제
```py
color
  ['orange','red','blue','green']

color.remove('red')
color
  ['orange','blue','green']
```
## 인덱스의 재할당과 삭제
- 인덱스 재할당 : 인덱스에 새로운 값을 할당한다.
- 인덱스 삭제 : del 함수를 사용한다.
- del 함수 : 특정 인덱스 값을 삭제 (remove()함수는 리스트 내의 특정 값을 삭제)

아래의 코드를 통해 인덱스 재할당과 삭제, del 함수를 알아보자
```py
color=['red','blue','green']
color[0]='orange'               #인덱스 재할당
color
  ['orange','blue','green']
del color[0]                    #del 함수를 통해 인덱스 삭제
color
['blue','green']
```
## 패킹과 언패킹
- 패킹(packing) : 한 변수에 여러 개의 데이터를 할당하는 것
- 언패킹(unpacking) : 한 변수의 데이터를 각각의 변수로 반환하는 것
```py
t=[1,2,3]           #1,2,3을 변수 t에 패킹
a,b,c=t             #t에 있는 값 1,2,3을 변수 a,b,c에 언패킹
print(t,a,b,c)
  [1,2,3] 1 2 3
```

아래의 코드에서 보는 것처럼 언패킹 시 할당받는 변수의 개수가 적거나 많으면 모두 에러가 발생한다.
```py
>>> t=[1,2,3]
>>> a,b,c,d,e=t
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: not enough values to unpack (expected 5, got 3)
>>> a,b=t
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: too many values to unpack (expected 2)
```

## 이차원 리스트 (행렬)
![image]([](..\..\..\..\..\..\..\Lumiere001\SW-Mentoring\commit\3b0fd135e1ff8519a305d0d440ba49a258e0f406))

- 이차원 리스트 : 리스트를 효율적으로 활용하기 위해 여러 개의 리스트를 하나의 변수에 할당하는 이차원 리스트
  - 아래 코드를 보자 
```py
kor_score=[49,79,20,100,80]
math_score=[43,59,85,30,90]
eng_score=[49,79,48,60,100]
midterm_score=[kor_score,math_score,eng_score]
midterm_score
  [[49,79,20,100,80],[43,59,85,30,90],[49,79,48,60,100]]
```
- 국어점수, 수학점수, 영어 점수를 각각 하나의 리스트로 보고 그 리스트에 있는 값들이 모두 하나의 리스트 변수에 할당되면, 그것을 이차원 리스트라고 할 수 있다. 
- 먼저 국어 점수, 수학 점수, 영어 점수를 각각 kor_score, math_score, eng_score에 할당하고, 그 각각의 변수를 모두 midterm_score에 할당한다.
  - midterm_score가 이차원 리스트가 된다.
 
```py
print(midterm_score[0][2])
  20
```
- 이차원 리스트에 인덱싱하여 값에 접근하기 위해서는 위 코드와 같이 대괄호 2개를 이용한다.
- 이차원 리스트를 행렬로 본다면 [0]은 행, [2]는 열을 뜻한다.
  - 생성된 이차원 리스트에서 [0]은 kor_score, [2]는 C를 의미하여 실행 결과 20을 화면에 출력한다.

# 3장 : 화면 입출력과 리스트 - 리스트의 메모리 관리 방식
리스트의 메모리 관리 방식은 교재를 참고 한다. (해당 부분을 꼼꼼히 읽고 이해 할 것)

여기에는 부가적으로 알아야 할 내용만 적어 둔다.

- (데이터 과학을 위한 파이썬 프로그래밍 p.90~95)

## 연산자 ==와 is
- == : 값을 비교하는 연산
- is : 메모리의 주소를 비교하는 연산
```py
a=300
b=300
a is b
  False
a==b
  True
```

## sort() 함수
- sort() 함수 : 리스트에 있는 값들의 순서를 오름차순으로 변환하는 함수
```py
a=[5,4,3,2,1]
a.sort()
print(a)
  [1,2,3,4,5]
```

## '='의 의미
```py
a=[5,4,3,2,1]
b=[1,2,3,4,5]
b=a
print(b)
  [5,4,3,2,1]
```
- '='의 의미 : 같다가 아닌, 메모리 주소에 해당 값을 할당(연결)한다는 의미이다.