# 포인터

포인터(pointer)는 메모리의 주소를 가지고 있는 변수이다. 컴퓨터 메모리는 주소로 접근할 수 있고 주소를 이용하여 값을 저장하기도 하고 값을 읽기도 한다.

- 메모리에서는 각 바이트(8비트)마다 고유한 주소가 매겨진다. 이들 주소를 이용하여 우리는 메모리 바이트에 접근할 수 있다.
- 프로그램에서 변수를 만들면 이들 변수는 컴파일러에 의하여 메모리 공간의 비어있는 위치를 차지한다.

## 주소 연산자 &

주소 연산자 &는 변수의 이름을 받아서 변수의 조소를 반환한다.

    #include <stdio.h>

    int main(void){
        int i = 10;
        char c = 69;
        double f = 12.3;

        printf("i의 주소: %u\n", &i); // 변수 i의 주소출력
        printf("c의 주소: %u\n", &c); // 변수 c의 주소출력
        printf("f의 주소: %u\n", &f); // 변수 f의 주소출력

        return 0;
    }

## 포인터 선언

포인터는 변수의 주소를 가지고 있는 변수이다. 포인터는 변수이지만 저장하고 있는 것이 보통의 변수처럼 데이터가 아니라, 메모리의 주소이다. 포인터도 변수이다. 변수임을 강조하기 위해 때때로 "포인터 변수" 라고 한다.

    int *p; // 정수를 가리키는 포인터 p

p는 정수 데이터를 가리키는 포인터이다. 현재는 선언만 하고 아직 초기화되지 않았으므로 포인터는 아무 의미 없는 값을 가지고 있다.

    char *pc; // 문자를 가리키는 포인터
    float *pf; // 실수(float형)을 가리키는 포인터 pf
    double *pd; // 실수(double형)를 가리키는 포인터 pd

### 포인터 선언할 때 주의점

여러 개의 포인터 변수를 한 줄에 선언할 때는 주의하여야 한다. 다음과 같이 선언하는 것은 잘못되었다.

    int *p1, p2, p3; // p2와 p3는 정수형 변수가 된다.
    
    int *p1, *p2, *p3; // 올바른 선언

## 포인터 초기화

포인터에는 주소가 저장되어야 하므로 &연사자를 이용하여 변수의 주소를 계산하여 포인터에 대입할 수 있다. (절대 주소값을 바로 대입하는 것은 피해야 한다.)

    int i = 10; // 정수변수 i가 선언되고 10으로 초기화된다.
    int *p; // 정수 포인터가 선언된다.
    p = &i; // 포인터 p에 변수 i의 주소를 저장한다.

### Ex1) 변수 주소 대입하기

    #include <stdio.h>

    int main(void) {
     double f = 12.3;
     double *pf = NULL; // NULL값을 저장하면 쓰레기 값이 들어가지 않는다.

     pf = &f;
     printf("%u %u\n", pf, &f);

     return 0;
    }

NULL은 stdio.h 에서 다음과 같이 정의된 포인터 상수로 0번지를 의미한다. 0번지 키는 일반적으로 사용할 수 없다. 따라서 포인터 변수의 값이 0이면 아무 것도 가리키고 있지 않다고 판단할 수 있다.

    #define NULL((void *)0)

## 간접 참조 연산자 *

&연산자는 변수의 주소를 구하여 포인터에 대입할 때 사용되는 연산자이다. 반면 *연산자는 포인터를 통하여 변수를 간접 참조할 때 사용하는 연산자이다.

    #include <stdio.h>

    int main(void){
        int i = 3000;
        int *p = NULL;

        p = &i;

        printf("i = %d\n", i);
        printf("*p = %d\n", *p);

        return 0;
    }

### Ex2) 포인터 값 변경

    #include <stdio.h>

    int main(void){
        int x = 10, y = 20;
        int *p;

        p = &x;
        printf("p = %d\n", p);
        printf("*p = %d\n\n", *p);

        p = &y;
        printf("p = %d\n", p);
        printf("*p = %d\n", *p);

        return 0;
    }

포인터 변수는 주소를 저장하는 변수이다. 포인터는 변수이기 때문에 저장된 주소를 다른 값으로 얼마든지 변경할 수 있다.

### Ex3) *를 이용하여 변수의 값 변경

    #include <stdio.h>

    int main(void){
        int i = 10;
        int *p;

        p = &i;
        printf("i = %d\n", i);

        *p = 20;
        printf("i = %d\n", i);

        return 0;
    }

간접 참조 연산자를 이용하여 포인터가 가리키는 변수의 값을 변경할 수 있다. 위의 예시처럼 *p = 20 은 포인터가 가리키는 위치에 20을 대입한다.

## 포인터 연산

포인터도 변수이므로 더하거나 뺄 수 있다. 포인터에 대해서는 사칙 연산 중에서 오직 덧셈과 뺄셈만이 허용된다. 하지만 포인터에 대한 연산은 일반적인 변수에 대한 연산과는 조금 다르다. 포인터 증가 연산인 ++을 적용했을 경우, 증가되는 값은 포인터가 가리키는 객체의 크기이다.

만약 char형 포인터를 증가시키면 char형 크기인 1바이트 만큼 증가한다. int형 포인터를 증가시키면 int형의 크기인 4바이트 만큼 증가한다. double형 포인터를 증가시키면 double형의 크기인 8바이트 만큼 포인터의 값이 증가한다. -- 연산자를 사용할 때도 마찬가지다.

### 간접 참조 연산자와 증감 연산자

    *p++;

이 문장은 p가 가리키는 위치에서 값을 가져온 후에 포인터 p를 증가한다. ++의 우선순위가 더 높지만 ++가 포인터의 뒤에 붙어 있으므로 *p를 먼저 수행한 후에 p에 대하여 ++가 수행된다.

    (*p)++;

만약 포인터가 가리키는 대상의 값을 증가하려고 했으면 위와 같이 해야 한다.

    v = *p++; // p가 가리키는 값을 v에 대입한 후에 p를 증가한다.
    v = (*p)++; // p가 가리키는 값을 v에 대입한 후에 p가 가리키는 값을 증가한다.
    v = *++p; // p를 증가시킨 후에 p가 가리키는 값을 v에 대입한다.
    v = ++*p; // p가 가리키는 값을 가져온 후에 그 값을 증가하여 v에 대입한다.

## 포인터의 형변환

C언어에서는 꼭 필요한 경우에, 명시적으로 포인터의 타입을 변경할 수 있다. 예를 들어서 double형 포인터를 int형 포인터로 타입을 변경할 수 있는 것이다. 이 경우에는 반드시 형변환 연산자를 앞에 써주어야 한다.

    double *pd = &f;
    int *pi;
    
    pi = (int *)pd; // double형의 포인터를 int형 포인터로 변환

포인터의 타입을 바꾸어서 메모리에 접근하는 것은 아주 조심스럽게 하여야 한다. 자신이 접근할 수 있는 범위를 넘어서 이웃 바이트를 건드리면 안된다.

### Ex4) 형 변환 후 출력

    #include <stdio.h>

    int main(void){
        int data = 0x0A0B0C0D;
        char *pc;

        pc = (char *)&data;
        for(int i = 0; i < 4; i++){
            printf("*(pc + %d) = %02X\n", i, *(pc + 1));
        }
        return 0;
    }
    /* 실행결과
        *(pc + 0) = 0D
        *(pc + 1) = 0C
        *(pc + 2) = 0B
        *(pc + 3) = 0A */

포인터의 증감 연산에서 포인터의 위험성을 조금은 느낄 수 있다. 포인터는 우리가 마음대로 증감시킬 수 있지만 증감된 포인터가 잘못된 위치를 가리킬 수도 있다. 우리가 만든 데이터가 아닌 남의 데이터를 가리킬 수도 있고 운영체제가 사용하는 데이터 영역을 가리킬 수도 있다. 이런 경우, 포인터를 이용하여 값을 쓰거나 읽게 되면 심각한 오류가 발생할 수 있다. C 컴파일러는 포인터의 증감 연산까지는 추적하지 못한다.

## 포인터와 함수

### 함수 호출시 인수 전달 방식

- 값에 의한 호출(call-by-value): 복사본이 전달된다.
- 참조에 의한 호출(call-by-reference): 원본이 전달된다.
  
C에서는 값에 의한 호출만을 지원한다. 참조에 의한 호출은 포인터를 이용하여서 간접 구현이 가능하다. 변수의 주소를 함수에 넘겨주면 호출된 함수에서는 이 포인터를 이용하여 원본 변수의 값을 수정할 수 있다.

### Ex5) Call-by-reference

    #include <stdio.h>
    void swap(int *px, int *py);

    int main(void){
        int a = 100, b = 200;

        printf("a = %d, b = %d\n", a, b);
        swap(&a, &b); // a, b의 주소값을 전달한다.
        printf("a = %d, b = %d\n", a, b);

        return 0;
    }

    void swap(int *px, int *py){
        int tmp;
        
        tmp = *px;
        *px = *py;
        *py = tmp;
    }

### scanf( ) 함수

참조에 의한 호출(Call-by-value)을 사용하는 전형적인 예가 바로 scanf( )함수이다.

참조에 의한 호출은 함수가 전역 변수를 사용하지 않고서도 외부의 변수들을 참조할 수 있는 합법적인 방법이다.

만약 프로그래머가 포인터를 통하여 원본 변수의 값이 변경되지 않도록 지정하고 싶으면 함수의 매개 변수를 선언할 때 앞에 const를 붙이면 된다.

    void sub(const int *p){
        *p = 0; // 오류! const로 선언되면 값을 변경할 수 없다.
    }

## 포인터와 배열

배열 이름은 포인터가 시작되는 주소와 같다.

### Ex6) 포인터와 배열의 관계 1

    #include <stdio.h>

    int main(void){
        int a[] = {10, 20, 30, 40, 50};

        printf("&a[0] = %u\n", &a[0]);
        printf("&a[1] = %u\n", &a[1]);
        printf("&a[2] = %u\n", &a[2]);
        
        printf("a = %u\n", a);

        return 0;
    }
    /* 실행결과
        &a[0] = 1245000
        &a[1] = 1245004
        &a[2] = 1245008
        a = 1245000 */

배열은 요소들이 메모리에서 연속된 공간을 차지하고 있음을 알 수 있다. 또한 a가 int형 배열임으로 각 요소들이 차지하는 메모리 공간은 4바이트이다. 마지막으로 놀라운 사실은 배열의 이름을 정수 형식으로 출력하면 배열의 첫번째 요소의 주소와 같다는 사실이다.

### Ex7) 포인터와 배열의 관계 2

    #include <stdio.h>

    int main(void){
        int a[] = {10, 20, 30, 40, 50};

        printf("a = %u\n", a);
        printf("a + 1 = %u\n", a +1);
        printf("*a = %d\n", *a);
        printf("*(a+1) = %d\n", *(a+1));

        return 0;
    }
    /* 실행결과
        a = 1245000
        a + 1 = 1245004
        *a = 10;
        *(a+1) = 20; */

배열 이름을 포인터라고 생각하고 *a를 출력하여 보면 첫 번째 요소 a[0]의 값이 출력됨을 알 수 있었다. 또한 a + i는 a가 포인터이므로 배열의 시작 주소에 (인덱스)x(배열요소의 크기)값이 더해진다.

    a + i == &a[i]
    *(a + i) == a[i]

배열의 이름이 포인터이기는 하지만 배열의 이름에다 다른 변수의 주소를 대입할 수는 없다. 왜냐하면 배열의 이름은 포인터 상수이기 때문이다. 즉 그 값이 변경될 수는 없다.

    int a[] = {1, 2, 3, 4};
    ++a; // 컴파일 오류, a는 포인터 상수이므로 변경불가

### 포인터를 배열처럼 사용

포인터도 배열 이름처럼 간주될 수 있고 배열과 똑같이 사용할 수 있다.

### Ex8) 포인터를 배열 이름처럼 사용

    #include <stdio.h>

    int main(void){
        int a[] = {10, 20, 30, 40, 50};
        int *p;

        p = a; // 포인터 p에 배열의 이름 a를 대입
        printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);
        printf("p[0] = %d p[1] = %d p[2] = %d\n\n", p[0], p[1], p[2]);

        p[0] = 60;
        p[1] = 70;
        p[2] = 80;

        printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);
        printf("p[0] = %d p[1] = %d p[2] = %d\n\n", p[0], p[1], p[2]);

        return 0;
    }
    /* 실행결과
        a[0] = 10 a[1] = 20 a[2] = 30
        p[0] = 10 p[1] = 20 p[2] = 30

        a[0] = 60 a[1] = 70 a[2] = 80
        p[0] = 60 p[1] = 70 p[3] = 80 */

### 배열 매개변수

매개 변수로 배열을 선언하게 되면 변수 b에서는 실제로 배열이 생성도지 않는다. b는 외부에서 전달되는 배열의 주소를 저장하는 포인터로 생성된다.

    int main(void){
        int a[3] = {1, 2, 3};

        sub(a, 3); // 배열의 이름은 포인터
    }

    void sub(int b[], int size){
        *b = 4; // 포인터 b를 통해서 원본 배열을 변경할 수 있다.
        *(b+1) = 5;
        *(b+2) = 6;
    }

매개변수로 배열을 선언할 때 포인터로 선언할 수도 있다.

    void sub(int *b, int size){
        b[0] = 4;
        b[1] = 5;
        b[2] = 6;
    }

## 포인터 사용의 장점

- 포인터를 이용하면 연결 리스트나 이진 트리 등의 향상된 자료 구조를 만들 수 있다.

- 메모리 매핑 하드웨어

- 참조에 의한 호출

- 동적 메모리 할당
